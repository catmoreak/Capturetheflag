// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum Difficulty {
  EASY
  MEDIUM
  HARD
  EXPERT
}

enum ChallengeStatus {
  ACTIVE
  DISABLED
  MAINTENANCE
  DRAFT
  ARCHIVED
}

enum UserRole {
  PLAYER
  ADMIN
  MODERATOR
  CREATOR
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  BANNED
  PENDING_VERIFICATION
}

enum CategoryType {
  WEB
  CRYPTO
  FORENSICS
  REVERSING
  MISC
  MOBILE
  STEGANOGRAPHY
  PWN
  HARDWARE
}

enum SubmissionStatus {
  CORRECT
  INCORRECT
  RATE_LIMITED
  DUPLICATE
  MALFORMED
}

enum AuditAction {
  USER_LOGIN
  USER_LOGOUT
  USER_REGISTER
  CHALLENGE_CREATE
  CHALLENGE_UPDATE
  CHALLENGE_DELETE
  FLAG_SUBMIT
  ADMIN_ACTION
  SETTINGS_CHANGE
  SECURITY_EVENT
}

enum NotificationType {
  CHALLENGE_SOLVED
  NEW_CHALLENGE
  LEADERBOARD_UPDATE
  SYSTEM_ANNOUNCEMENT
  SECURITY_ALERT
  ACHIEVEMENT_UNLOCKED
}

enum ContestStatus {
  UPCOMING
  ACTIVE
  COMPLETED
  CANCELLED
}

enum TeamRole {
  LEADER
  MEMBER
}

// User model with enhanced security and features
model User {
  id                String     @id @default(cuid())
  name              String     @unique @db.VarChar(50)
  email             String?    @unique @db.VarChar(255)
  emailVerified     Boolean    @default(false)
  passwordHash      String?    @db.VarChar(255) // For password-based auth
  avatar            String?    @db.Text
  bio               String?    @db.VarChar(500)
  role              UserRole   @default(PLAYER)
  status            UserStatus @default(ACTIVE)
  totalScore        Int        @default(0)
  solvedChallenges  Int        @default(0)
  rank              Int?       // Computed field for leaderboard position
  lastLoginAt       DateTime?
  lastActiveAt      DateTime?
  loginAttempts     Int        @default(0)
  lockedUntil       DateTime?
  preferences       Json?      // User preferences as JSON
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  // Relations
  completions       ChallengeCompletion[]
  submissions       FlagSubmission[]
  createdChallenges Challenge[]             @relation("ChallengeCreator")
  sessions          UserSession[]
  notifications     Notification[]
  teamMemberships   TeamMember[]
  apiKeys           ApiKey[]
  auditLogs         AuditLog[]
  ledTeams          Team[]                  @relation("TeamLeader")
  contestParticipations ContestParticipant[]
  achievements      UserAchievement[]
  stats             UserStats?
  createdTeams      Team[]                  @relation("TeamCreator")
  createdContests   Contest[]               @relation("ContestCreator")
  firstSolves       ChallengeStats[]        @relation("FirstSolver")

  // Constraints
  @@unique([email])
  @@unique([name])

  // Indexes for performance
  @@index([totalScore])
  @@index([solvedChallenges])
  @@index([status])
  @@index([role])
  @@index([lastActiveAt])
  @@index([createdAt])
  @@index([emailVerified])

  // Check constraints
  // Note: PostgreSQL check constraints would be added via migration

  @@map("users")
}

// Challenge model - store challenges in database instead of hardcoding
model Challenge {
  id          Int      @id @default(autoincrement())
  title       String   @unique @db.VarChar(200)
  description String   @db.Text
  category    CategoryType
  difficulty  Difficulty
  points      Int      @default(100)
  flag        String   @db.VarChar(255) // Hashed flag
  hint        String?  @db.Text
  files       Json?    // Store file metadata as JSON
  status      ChallengeStatus @default(ACTIVE)
  maxAttempts Int?     // Maximum submission attempts per user
  timeLimit   Int?     // Time limit in seconds
  tags        String[] // Array of tags for better categorization
  creatorId   String
  creator     User     @relation("ChallengeCreator", fields: [creatorId], references: [id])
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  completions ChallengeCompletion[]
  submissions FlagSubmission[]
  contestChallenges ContestChallenge[]
  stats       ChallengeStats?

  // Constraints
  // Points must be positive
  // Max attempts must be positive if set
  // Time limit must be positive if set

  // Indexes
  @@index([category])
  @@index([difficulty])
  @@index([status])
  @@index([points])
  @@index([creatorId])
  @@index([createdAt])
  @@map("challenges")
}

// Enhanced completion tracking
model ChallengeCompletion {
  id            String   @id @default(cuid())
  userId        String
  challengeId   Int
  points        Int      // Points awarded (may differ from base challenge points)
  completionTime Int     // Time taken in seconds
  attempts      Int      @default(1) // Number of attempts made
  hintsUsed     Int      @default(0) // Number of hints used
  completedAt   DateTime @default(now())

  // Relations
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  // Ensure one completion per user per challenge
  @@unique([userId, challengeId])
  @@index([completedAt])
  @@index([points])
  @@map("challenge_completions")
}

// Track all flag submissions for analytics
model FlagSubmission {
  id          String   @id @default(cuid())
  userId      String
  challengeId Int
  submittedFlag String @db.VarChar(500)
  status      SubmissionStatus @default(INCORRECT)
  submittedAt DateTime @default(now())
  ipAddress   String?  @db.VarChar(45)
  userAgent   String?  @db.Text

  // Relations
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([userId, challengeId])
  @@index([submittedAt])
  @@index([status])
  @@map("flag_submissions")
}

// Leaderboard snapshots for performance
model LeaderboardSnapshot {
  id        String   @id @default(cuid())
  userId    String
  userName  String   @db.VarChar(50)
  score     Int
  rank      Int
  period    String   // 'daily', 'weekly', 'monthly', 'all-time'
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([period, rank])
  @@index([createdAt])
  @@map("leaderboard_snapshots")
}

// System settings and configuration
model SystemSetting {
  id    String @id @default(cuid())
  key   String @unique @db.VarChar(100)
  value String @db.Text
  type  String @default("string") // 'string', 'number', 'boolean', 'json'

  @@map("system_settings")
}

// User sessions for authentication
model UserSession {
  id           String   @id @default(cuid())
  userId       String
  sessionToken String   @unique @db.VarChar(500)
  expiresAt    DateTime
  ipAddress    String?  @db.VarChar(45)
  userAgent    String?  @db.Text
  createdAt    DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([userId])
  @@index([expiresAt])
  @@map("user_sessions")
}

// API keys for programmatic access
model ApiKey {
  id          String   @id @default(cuid())
  userId      String
  name        String   @db.VarChar(100)
  keyHash     String   @unique @db.VarChar(255)
  permissions Json     // API permissions as JSON
  lastUsedAt  DateTime?
  expiresAt   DateTime?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([userId])
  @@index([isActive])
  @@map("api_keys")
}

// Notifications system
model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      NotificationType
  title     String   @db.VarChar(200)
  message   String   @db.Text
  data      Json?    // Additional notification data
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([userId, isRead])
  @@index([createdAt])
  @@map("notifications")
}

// Team/Clan system
model Team {
  id          String   @id @default(cuid())
  name        String   @unique @db.VarChar(100)
  description String?  @db.VarChar(500)
  avatar      String?  @db.Text
  leaderId    String
  creatorId   String
  totalScore  Int      @default(0)
  memberCount Int      @default(1)
  maxMembers  Int      @default(10)
  isPublic    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  leader  User        @relation("TeamLeader", fields: [leaderId], references: [id])
  creator User        @relation("TeamCreator", fields: [creatorId], references: [id])
  members TeamMember[]
  contestParticipants ContestParticipant[]

  // Indexes
  @@index([leaderId])
  @@index([creatorId])
  @@index([totalScore])
  @@map("teams")
}

// Team membership
model TeamMember {
  id        String   @id @default(cuid())
  teamId    String
  userId    String
  role      TeamRole @default(MEMBER)
  joinedAt  DateTime @default(now())

  // Relations
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Unique constraint: one user per team
  @@unique([teamId, userId])
  @@index([userId])
  @@map("team_members")
}

// Contest/Tournament system
model Contest {
  id          String   @id @default(cuid())
  name        String   @unique @db.VarChar(200)
  description String   @db.Text
  status      ContestStatus @default(UPCOMING)
  startTime   DateTime
  endTime     DateTime
  maxParticipants Int?
  isPublic    Boolean  @default(true)
  rules       Json?    // Contest rules as JSON
  prizes      Json?    // Prize structure as JSON
  creatorId   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  creator     User               @relation("ContestCreator", fields: [creatorId], references: [id])
  challenges  ContestChallenge[]
  participants ContestParticipant[]

  // Indexes
  @@index([status])
  @@index([startTime])
  @@index([endTime])
  @@index([creatorId])
  @@map("contests")
}

// Contest challenges
model ContestChallenge {
  id          String @id @default(cuid())
  contestId   String
  challengeId Int
  points      Int    // Contest-specific points
  order       Int?   // Display order

  // Relations
  contest   Contest   @relation(fields: [contestId], references: [id], onDelete: Cascade)
  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)

  // Unique constraint: one challenge per contest
  @@unique([contestId, challengeId])
  @@index([challengeId])
  @@map("contest_challenges")
}

// Contest participants
model ContestParticipant {
  id        String @id @default(cuid())
  contestId String
  userId    String
  teamId    String?
  score     Int    @default(0)
  rank      Int?
  joinedAt  DateTime @default(now())

  // Relations
  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  team    Team?   @relation(fields: [teamId], references: [id], onDelete: SetNull)

  // Unique constraint: one user per contest
  @@unique([contestId, userId])
  @@index([userId])
  @@index([score])
  @@map("contest_participants")
}

// Audit log for admin actions
model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  action    AuditAction @db.VarChar(100)
  resource  String   @db.VarChar(100)
  details   Json?
  ipAddress String?  @db.VarChar(45)
  userAgent String?  @db.Text
  createdAt DateTime @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Indexes
  @@index([action])
  @@index([createdAt])
  @@index([userId])
  @@map("audit_logs")
}

// Rate limiting for API endpoints
model RateLimit {
  id        String   @id @default(cuid())
  identifier String  @db.VarChar(255) // IP address or user ID
  endpoint  String   @db.VarChar(255)
  requests  Int      @default(1)
  windowStart DateTime
  windowEnd DateTime

  // Unique constraint per identifier and endpoint
  @@unique([identifier, endpoint])
  @@index([windowEnd])
  @@map("rate_limits")
}

// Achievement system
model Achievement {
  id          String @id @default(cuid())
  name        String @unique @db.VarChar(100)
  description String @db.VarChar(500)
  icon        String @db.VarChar(100)
  category    String @db.VarChar(50)
  points      Int    @default(0)
  rarity      String @default("common") // 'common', 'rare', 'epic', 'legendary'
  requirements Json   // Achievement requirements as JSON
  isActive    Boolean @default(true)
  createdAt   DateTime @default(now())

  // Relations
  unlocks UserAchievement[]

  @@index([category])
  @@index([rarity])
  @@map("achievements")
}

// User achievements
model UserAchievement {
  id            String @id @default(cuid())
  userId        String
  achievementId String
  unlockedAt    DateTime @default(now())

  // Relations
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  // Unique constraint: one achievement per user
  @@unique([userId, achievementId])
  @@index([unlockedAt])
  @@map("user_achievements")
}

// User statistics for advanced analytics
model UserStats {
  id                String @id @default(cuid())
  userId            String @unique
  totalSubmissions  Int    @default(0)
  correctSubmissions Int   @default(0)
  averageSolveTime  Float?
  favoriteCategory  CategoryType?
  streakCurrent     Int    @default(0)
  streakBest        Int    @default(0)
  lastSolveAt       DateTime?
  updatedAt         DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_stats")
}

// Challenge statistics
model ChallengeStats {
  id                String @id @default(cuid())
  challengeId       Int    @unique
  totalAttempts     Int    @default(0)
  successfulAttempts Int   @default(0)
  averageSolveTime  Float?
  firstSolveTime    Int?
  firstSolverId     String?
  difficultyRating  Float? // Community difficulty rating
  updatedAt         DateTime @updatedAt

  // Relations
  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  firstSolver User?   @relation(fields: [firstSolverId], references: [id], onDelete: SetNull)

  @@index([firstSolverId])
  @@map("challenge_stats")
}
